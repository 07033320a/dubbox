<!DOCTYPE html><html><head><title>rest</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0}body{font-family:Helvetica,arial,freesans,clean,sans-serif;font-size:14px;line-height:1.6;color:#333;background-color:#fff;padding:20px;max-width:960px;margin:0 auto}body>:first-child{margin-top:0!important}body>:last-child{margin-bottom:0!important}p,blockquote,ul,ol,dl,table,pre{margin:15px 0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:700;-webkit-font-smoothing:antialiased}h1 tt,h1 code,h2 tt,h2 code,h3 tt,h3 code,h4 tt,h4 code,h5 tt,h5 code,h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}body>h2:first-child,body>h1:first-child,body>h1:first-child+h2,body>h3:first-child,body>h4:first-child,body>h5:first-child,body>h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1+p,h2+p,h3+p,h4+p,h5+p,h6+p{margin-top:10px}a{color:#4183C4;text-decoration:none}a:hover{text-decoration:underline}ul,ol{padding-left:30px}ul li>:first-child,ol li>:first-child,ul li ul:first-of-type,ol li ol:first-of-type,ul li ol:first-of-type,ol li ul:first-of-type{margin-top:0}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:700;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt>:first-child{margin-top:0}dl dt>:last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd>:first-child{margin-top:0}dl dd>:last-child{margin-bottom:0}pre,code,tt{font-size:12px;font-family:Consolas,"Liberation Mono",Courier,monospace}code,tt{margin:0 0;padding:0 0;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre>code{margin:0;padding:0;white-space:pre;border:none;background:0 0}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:none}kbd{-moz-border-bottom-colors:none;-moz-border-left-colors:none;-moz-border-right-colors:none;-moz-border-top-colors:none;background-color:#DDD;background-image:linear-gradient(#F1F1F1,#DDD);background-repeat:repeat-x;border-color:#DDD #CCC #CCC #DDD;border-image:none;border-radius:2px 2px 2px 2px;border-style:solid;border-width:1px;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;line-height:10px;padding:1px 4px}blockquote{border-left:4px solid #DDD;padding:0 15px;color:#777}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:0}hr{clear:both;margin:15px 0;height:0;overflow:hidden;border:none;background:0 0;border-bottom:4px solid #ddd;padding:0}table th{font-weight:700}table th,table td{border:1px solid #ccc;padding:6px 13px}table tr{border-top:1px solid #ccc;background-color:#fff}table tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%}</style><style type="text/css">.highlight{background:#fff}.highlight .c{color:#998;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{font-weight:700}.highlight .o{font-weight:700}.highlight .cm{color:#998;font-style:italic}.highlight .cp{color:#999;font-weight:700}.highlight .c1{color:#998;font-style:italic}.highlight .cs{color:#999;font-weight:700;font-style:italic}.highlight .gd{color:#000;background-color:#fdd}.highlight .gd .x{color:#000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000;background-color:#dfd}.highlight .gi .x{color:#000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:700}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{font-weight:700}.highlight .kd{font-weight:700}.highlight .kp{font-weight:700}.highlight .kr{font-weight:700}.highlight .kt{color:#458;font-weight:700}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:teal}.highlight .nb{color:#0086B3}.highlight .nc{color:#458;font-weight:700}.highlight .no{color:teal}.highlight .ni{color:purple}.highlight .ne{color:#900;font-weight:700}.highlight .nf{color:#900;font-weight:700}.highlight .nn{color:#555}.highlight .nt{color:navy}.highlight .nv{color:teal}.highlight .ow{font-weight:700}.highlight .w{color:#bbb}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .mi{color:#099}.highlight .mo{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc{color:teal}.highlight .vg{color:teal}.highlight .vi{color:teal}.highlight .il{color:#099}.task-list{padding-left:10px;margin-bottom:0}.task-list li{margin-left:20px}.task-list-item{list-style-type:none;padding-left:10px}.task-list-item label{font-weight:400}.task-list-item.enabled label{cursor:pointer}.task-list-item+.task-list-item{margin-top:3px}.task-list-item-checkbox{display:inline-block;margin-left:-20px;margin-right:3px;vertical-align:1px}</style></head><body><h1>在Dubbo中开发REST风格的远程调用（RESTful Remoting）</h1><p>作者：当当网 沈理 <a href="mailto:shenli@dangdang.com">shenli@dangdang.com</a></p><p>文档版权：Creative Commons 3.0许可证 署名-非商业性使用-禁止演绎</p><p>完善中……</p><blockquote><p>本文篇幅较长，因为REST本身涉及面较多。另外，本文参照Spring等的文档风格，不仅仅局限于框架用法的阐述，同时也努力呈现框架的设计理念和优良应用的架构思想。</p><p>对于想粗略了解dubbo和REST的人，只需浏览 <code>概述</code> 至 <code>标准Java REST API：JAX-RS简介</code> 几节即可。</p></blockquote><p>TODO 生成可点击的目录</p><h2>目录</h2><ul class="task-list"><li>概述</li><li>REST的优点</li><li>应用场景</li><li>快速入门</li><li>标准Java REST API：JAX-RS简介</li><li>REST服务提供端详解<ul class="task-list"><li>HTTP POST/GET的实现</li><li>Annotation放在接口类还是实现类</li><li>JSON、XML等多数据格式的支持</li><li>XML数据格式的额外要求</li><li>定制序列化</li><li>配置REST Server的实现</li><li>获取上下文（Context）信息<br></li><li>配置端口号和Context Path<br></li><li>配置线程数和IO线程数</li><li>配置长连接<br></li><li>配置消费端的超时时间和HTTP连接数<br></li><li>GZIP数据压缩<br></li><li>是否应该透明发布REST服务<br></li><li>用Annotation取代部分Spring XML配置</li><li>添加自定义的Filter、Interceptor等</li></ul></li><li>REST服务消费端详解<ul class="task-list"><li>场景1：非dubbo的消费端调用dubbo的REST服务<br></li><li>场景2：dubbo消费端调用dubbo的REST服务<br></li><li>场景3：dubbo的消费端调用非dubbo的REST服务<br></li></ul></li><li>Dubbo中JAX-RS的限制<br></li><li>Dubbo当前体系可能的不足之处（与REST相关的）<br><ul class="task-list"><li>RpcContext的侵入性<br></li><li>Protocol配置的局限性<br></li><li>XML命名不符合spring规范<br></li></ul></li><li>REST最佳实践<br></li><li>性能基准测试<br><ul class="task-list"><li>测试环境<br></li><li>测试脚本<br></li><li>测试结果</li></ul></li><li>扩展讨论<ul class="task-list"><li>REST与Thrift、Protobuf等的对比<br></li><li>REST与传统WebServices的对比</li><li>JAX-RS与Spring MVC的对比<br></li></ul></li><li>未来<br></li></ul><h2>概述</h2><p>dubbo支持多种远程调用方式，例如dubbo RPC（二进制序列化 + tcp协议）、http invoker（二进制序列化 + http协议，至少在开源版本没发现对文本序列化的支持）、hessian（二进制序列化 + http协议）、WebServices （文本序列化 + http协议）等等，但缺乏对当今特别流行的REST风格远程调用（文本序列化 + http协议）的支持。</p><p>有鉴于此，我们基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写），为dubbo提供了接近透明的REST调用支持。由于完全兼容Java标准API，所以为dubbo开发的所有REST服务，未来脱离dubbo或者任何特定的REST底层实现一般也可以正常运行。</p><p>特别值得指出的是，我们并不需要完全严格遵守REST的原始定义和架构风格。即使著名的Twitter REST API也会根据情况做适度调整，而不是机械的遵守原始的REST风格。</p><blockquote><p>附注：我们将这个功能称之为REST风格的远程调用，即RESTful Remoting（抽象的远程处理或者调用），而不是叫RESTful RPC（具体的远程“过程”调用），是因为REST和RPC本身可以被认为是两种不同的风格。在dubbo的REST实现中，可以说有两个面向，其一是提供或消费正常的REST服务，其二是将REST作为dubbo RPC体系中一种协议实现，而RESTful Remoting同时涵盖了这个面向。</p></blockquote><h2>REST的优点</h2><p>以下摘自维基百科：</p><ul class="task-list"><li>可更高效利用缓存来提高响应速度</li><li>通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性</li><li>浏览器即可作为客户端，简化软件需求</li><li>相对于其他叠加在HTTP协议之上的机制，REST的软件依赖性更小</li><li>不需要额外的资源发现机制</li><li>在软件技术演进中的长期的兼容性更好</li></ul><p>这里我还想特别补充REST的显著优点：基于简单的文本格式消息和通用的HTTP协议，使它具备极广的适用性，几乎所有语言和平台都对它提供支持，同时其学习和使用的门槛也较低。</p><h2>应用场景</h2><p>正是由于REST在适用性方面的优点，所以在dubbo中支持REST，可以为当今多数主流的远程调用场景都带来（显著）好处：</p><ol class="task-list"><li><p>显著简化企业内部的异构系统之间的（跨语言）调用。此处主要针对这种场景：dubbo的系统做服务提供端，其他语言的系统（也包括某些不基于dubbo的java系统）做服务消费端，两者通过HTTP和文本消息进行通信。即使相比Thrift、ProtoBuf等二进制跨语言调用方案，REST也有自己独特的优势（详见后面讨论）</p></li><li><p>显著简化对外Open API（开放平台）的开发。既可以用dubbo来开发专门的Open API应用，也可以将原内部使用的dubbo service直接“透明”发布为对外的Open REST API（当然dubbo本身未来最好可以较透明的提供诸如权限控制、频次控制、计费等诸多功能）</p></li><li><p>显著简化手机（平板）APP或者PC桌面客户端开发。类似于2，既可以用dubbo来开发专门针对无线或者桌面的服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给手机APP或桌面程序。当然在有些项目中，手机或桌面程序也可以直接访问以上场景2中所述的Open API。</p></li><li><p>显著简化浏览器AJAX应用的开发。类似于2，既可以用dubbo来开发专门的AJAX服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给浏览器中JavaScript。当然，很多AJAX应用更适合与web框架协同工作，所以直接访问dubbo service在很多web项目中未必是一种非常优雅的架构。</p></li><li><p>为企业内部的dubbo系统之间（即服务提供端和消费端都是基于dubbo的系统）提供一种基于文本的、易读的远程调用方式。</p></li><li><p>一定程度简化dubbo系统对其它异构系统的调用。可以用类似dubbo的简便方式“透明”的调用非dubbo系统提供的REST服务（不管服务提供端是在企业内部还是外部）</p></li></ol><p>需要指出的是，我认为1～3是dubbo的REST调用最有价值的三种应用场景，并且我们为dubbo添加REST调用，其最主要到目的也是面向服务的提供端，即开发REST服务来提供给非dubbo的（异构）消费端。</p><p>归纳起来，所有应用场景如下图所示：<br><a href="images/rest.jpg" target="_blank"><img src="images/rest.jpg" alt="no image found" style="max-width:100%"></a></p><p>借用Java过去最流行的宣传语，为dubbo添加REST调用后，可以实现服务的”一次编写，到处访问“，理论上可以面向全世界开放，从而真正实现比较理想化的面向服务架构（SOA）。</p><p>当然，传统的WebServices（WSDL/SOAP）也基本同样能满足以上场景（除了场景4）的要求（甚至还能满足那些需要企业级特性的场景），但由于其复杂性等问题，现在已经越来越少被实际采用了。</p><h2>快速入门</h2><p>在dubbo中开发一个REST风格的服务会比较简单，下面以一个注册用户的简单服务为例说明。</p><p>这个服务要实现的功能是提供如下URL（注：这个URL不是完全符合REST的风格，但是更简单实用）：</p><pre><code>http://localhost:8080/users/register
</code></pre><p>而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册。</p><p>首先，开发服务的接口：</p><div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>    
   <span class="kt">void</span> <span class="nf">registerUser</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">);</span>
<span class="o">}</span>
</pre></div><p>然后，开发服务的实现：</p><div class="highlight highlight-java"><pre><span class="nd">@Path</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceImpl</span> <span class="kd">implements</span> <span class="n">UserService</span> <span class="o">{</span>

    <span class="nd">@POST</span>
    <span class="nd">@Path</span><span class="o">(</span><span class="s">"register"</span><span class="o">)</span>
    <span class="nd">@Consumes</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">})</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerUser</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// save the user...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div><p>上面的服务实现代码非常简单，但是由于REST服务是要被发布到特定HTTP URL，供任意语言客户端甚至浏览器来访问，所以这里要额外添加了几个JAX-RS的标准annotation来做相关的配置：</p><p><a href="https://github.com/Path" class="user-mention">@Path</a>("users")：指定访问UserService的URL相对路径是/users，即http://localhost:8080/users</p><p><a href="https://github.com/Path" class="user-mention">@Path</a>("register")：指定访问registerUser()方法的URL相对路径是/register，再结合上一个<a href="https://github.com/Path" class="user-mention">@Path</a>为UserService指定的路径，则调用UserService.register()的完整路径为http://localhost:8080/users/register</p><p><a href="https://github.com/POST" class="user-mention">@POST</a>：指定访问registerUser()用HTTP POST方法</p><p>@Consumes({MediaType.APPLICATION_JSON})：指定registerUser()接收JSON格式的数据。REST框架会自动将JSON数据反序列化为User对象</p><p>最后，在spring配置文件中添加此服务，即完成所有服务开发工作：</p><div class="highlight highlight-xml"><pre><span class="c">&lt;!-- 用rest协议在8080端口暴露服务 --&gt;</span>
<span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">port=</span><span class="s">"8080"</span><span class="nt">/&gt;</span>

<span class="c">&lt;!-- 声明需要暴露的服务接口 --&gt;</span>
<span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"xxx.UserService"</span> <span class="na">ref=</span><span class="s">"userService"</span><span class="nt">/&gt;</span>

<span class="c">&lt;!-- 和本地bean一样实现服务 --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userService"</span> <span class="na">class=</span><span class="s">"xxx.UserServiceImpl"</span> <span class="nt">/&gt;</span>
</pre></div><h2>标准Java REST API：JAX-RS简介</h2><p>JAX-RS是标准的Java REST API，得到了业界的广泛支持和应用，其著名的开源实现就有很多，包括Oracle的Jersey，RedHat的RestEasy，Apache的CXF和Wink，以及restlet等等。另外，所有支持JavaEE 6.0以上规范的商用JavaEE应用服务器都对JAX-RS提供了支持。因此，JAX-RS是一种已经非常成熟的解决方案，并且采用它没有任何所谓vendor lock-in的问题。</p><p>JAX-RS在网上的资料非常丰富，例如下面的入门教程：</p><ul class="task-list"><li>Oracle官方的tutorial：<a href="http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm">http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm</a></li><li>IBM developerWorks中国站文章：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/">http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/</a></li></ul><p>更多的资料请自行google或者百度一下。就学习JAX-RS来说，一般主要掌握其各种annotation的用法即可。</p><blockquote><p>注意：dubbo是基于JAX-RS 2.0版本的，有时候需要注意一下资料或REST实现所涉及的版本。</p></blockquote><h2>REST服务提供端详解</h2><p>下面我们扩充“快速入门”中的UserService，进一步展示在dubbo中REST服务提供端的开发要点。</p><h3>HTTP POST/GET的实现</h3><p>REST服务中虽然建议使用HTTP协议中四种标准方法POST、DELETE、PUT、GET来分别实现常见的“增删改查”，但实际中，我们一般情况直接用POST来实现“增改”，GET来实现“删查”即可（DELETE和PUT甚至会被一些防火墙阻挡）。</p><p>前面已经简单演示了POST的实现，在此，我们为UserService添加一个获取注册用户资料的功能，来演示GET的实现。</p><p>这个功能就是要实现客户端通过访问如下不同URL来获取不同ID的用户资料：</p><pre><code>http://localhost:8080/users/1001
http://localhost:8080/users/1002
http://localhost:8080/users/1003
</code></pre><p>当然，也可以通过其他形式的URL来访问不同ID的用户资料，例如：</p><pre><code>http://localhost:8080/users/load?id=1001
</code></pre><p>JAX-RS本身可以支持所有这些形式。但是上面那种在URL路径中包含查询参数的形式（http://localhost:8080/users/1001） 更符合REST的一般习惯，所以更推荐大家来使用。下面我们就为UserService添加一个getUser()方法来实现这种形式的URL访问：</p><div class="highlight highlight-java"><pre><span class="nd">@GET</span>
<span class="nd">@Path</span><span class="o">(</span><span class="s">"{id : \\d+}"</span><span class="o">)</span>
<span class="nd">@Produces</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">})</span>
<span class="kd">public</span> <span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@PathParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div><p><a href="https://github.com/GET" class="user-mention">@GET</a>：指定用HTTP GET方法访问</p><p><a href="https://github.com/Path" class="user-mention">@Path</a>("{id : \d+}")：根据上面的功能需求，访问getUser()的URL应当是“http://localhost:8080/users/ + 任意数字"，并且这个数字要被做为参数传入getUser()方法。 这里的annotation配置中，<a href="https://github.com/Path" class="user-mention">@Path</a>中间的{id: xxx}指定URL相对路径中包含了名为id参数，而它的值也将被自动传递给下面用@PathParam("id")修饰的方法参数id。{id:后面紧跟的\d+是一个正则表达式，指定了id参数必须是数字。</p><p>@Produces({MediaType.APPLICATION_JSON})：指定getUser()输出JSON格式的数据。框架会自动将User对象序列化为JSON数据。</p><h3>Annotation放在接口类还是实现类</h3><p>在Dubbo中开发REST服务主要都是通过JAX-RS的annotation来完成配置的，在上面的示例中，我们都是将annotation放在服务的实现类中。但其实，我们完全也可以将annotation放到服务的接口上，这两种方式是完全等价的，例如：</p><div class="highlight highlight-java"><pre><span class="nd">@Path</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserService</span> <span class="o">{</span>

    <span class="nd">@GET</span>
    <span class="nd">@Path</span><span class="o">(</span><span class="s">"{id : \\d+}"</span><span class="o">)</span>
    <span class="nd">@Produces</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">})</span>
    <span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@PathParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</pre></div><p>在一般应用中，我们建议将annotation放到服务实现类，这样annotation和java实现代码位置更接近，更便于开发和维护。另外更重要的是，我们一般倾向于避免对接口的污染，保持接口的纯净性和广泛适用性。</p><p>但是，如后文所述，如果我们要用dubbo直接开发的消费端来访问此服务，则annotation必须放到接口上。</p><p>如果接口和实现类都同时添加了annotation，则实现类的annotation配置会生效，接口上的annotation被直接忽略。</p><h3>JSON、XML等多数据格式的支持</h3><p>在dubbo中开发的REST服务可以同时支持传输多种格式的数据，以给客户端提供最大的灵活性。其中我们目前对最常用的JSON和XML格式特别添加了额外的功能。</p><p>比如，我们要让上例中的getUser()方法支持分别返回JSON和XML格式的数据，只需要在annotation中同时包含两种格式即可：</p><div class="highlight highlight-java"><pre><span class="nd">@Produces</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">,</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">TEXT_XML</span><span class="o">})</span>
<span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@PathParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
</pre></div><p>或者也可以直接用字符串（还支持通配符）表示MediaType：</p><div class="highlight highlight-java"><pre><span class="nd">@Produces</span><span class="o">({</span><span class="s">"application/json"</span><span class="o">,</span> <span class="s">"text/xml"</span><span class="o">})</span>
<span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@PathParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
</pre></div><p>如果所有方法都支持同样类型的输入输出数据格式，则我们无需在每个方法上做配置，只需要在服务类上添加annotation即可：</p><div class="highlight highlight-java"><pre><span class="nd">@Path</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
<span class="nd">@Consumes</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">,</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">TEXT_XML</span><span class="o">})</span>
<span class="nd">@Produces</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">,</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">TEXT_XML</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceImpl</span> <span class="kd">implements</span> <span class="n">UserService</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>

</pre></div><p>在一个REST服务同时对多种数据格式支持的情况下，根据JAX-RS标准，一般是通过HTTP中的MIME header（content-type和accept）来指定当前想用的是哪种格式的数据。</p><p>但是在dubbo中，我们还自动支持目前业界普遍使用的方式，即用一个URL后缀（.json和.xml）来指定想用的数据格式。例如，在添加上述annotation后，直接访问http://localhost:8888/users/1001.json则表示用json格式，直接访问http://localhost:8888/users/1002.xml则表示用xml格式，比用HTTP Header更简单直观。Twitter、微博等的REST API都是采用这种方式。</p><p>如果你既不加HTTP header，也不加后缀，则dubbo的REST会优先启用在以上annotation定义中排位最靠前的那种数据格式。</p><blockquote><p>注意：这里要支持XML格式数据，在annotation中既可以用MediaType.TEXT_XML，也可以用MediaType.APPLICATION_XML，但是TEXT_XML是更常用的，并且如果要利用上述的URL后缀方式来指定数据格式，只能配置为TEXT_XML才能生效。</p></blockquote><h3>XML数据格式的额外要求</h3><p>由于JAX-RS的实现一般都用标准的JAXB（Java API for XML Binding）来序列化和反序列化XML格式数据，所以我们需要为每一个要用XML传输的对象添加一个类级别的JAXB annotation，否则序列化将报错。例如为getUser()中返回的User添加如下：</p><div class="highlight highlight-java"><pre><span class="nd">@XmlRootElement</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div><p>此外，如果service方法中的返回值是Java的 primitive类型（如int，long，float，double等），最好为它们添加一层wrapper对象，因为JAXB不能直接序列化primitive类型。</p><p>例如，我们想让前述的registerUser()方法返回服务器端为用户生成的ID号：</p><div class="highlight highlight-java"><pre><span class="kt">long</span> <span class="nf">registerUser</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">);</span>
</pre></div><p>由于primitive类型不被JAXB序列化支持，所以添加一个wrapper对象：</p><div class="highlight highlight-java"><pre><span class="nd">@XmlRootElement</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegistrationResult</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">RegistrationResult</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">RegistrationResult</span><span class="o">(</span><span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setId</span><span class="o">(</span><span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div><p>并修改service方法：</p><div class="highlight highlight-java"><pre><span class="n">RegistrationResult</span> <span class="nf">registerUser</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">);</span>
</pre></div><p>这样不但能够解决XML序列化的问题，而且使得返回的数据都符合XML和JSON的规范。例如，在JSON中，返回的将是如下形式：</p><div class="highlight highlight-javascript"><pre><span class="p">{</span><span class="s2">"id"</span><span class="o">:</span> <span class="mi">1001</span><span class="p">}</span>
</pre></div><p>如果不加wrapper，JSON返回值将直接是</p><pre><code>1001    
</code></pre><p>而在XML中，加wrapper后返回值将是：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;registrationResult&gt;</span>
    <span class="nt">&lt;id&gt;</span>1002<span class="nt">&lt;/id&gt;</span>
<span class="nt">&lt;/registrationResult&gt;</span>
</pre></div><p>这种wrapper对象其实利用所谓Data Transfer Object（DTO）模式，采用DTO还能对传输数据做更多有用的定制。</p><h3>定制序列化</h3><p>如上所述，REST的底层实现会在service的对象和JSON/XML数据格式之间自动做序列化/反序列化。但有些场景下，如果觉得这种自动转换不满足要求，可以对其做定制。</p><p>Dubbo中的REST实现是用JAXB做XML序列化，用Jackson做JSON序列化，所以在对象上添加JAXB或Jackson的annotation即可以定制映射。</p><p>例如，定制对象属性映射到XML元素的名字：</p><div class="highlight highlight-java"><pre><span class="nd">@XmlRootElement</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="c1">// 在有getter的情况下不能把这个annotation修饰到field上</span>
    <span class="nd">@XmlElement</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"username"</span><span class="o">)</span> 
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div><p>定制对象属性映射到JSON字段的名字：</p><div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>

    <span class="nd">@JsonProperty</span><span class="o">(</span><span class="s">"username"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</pre></div><p>更多资料请参考JAXB和Jackson的官方文档，或自行google。</p><h3>配置REST Server的实现</h3><p>目前在dubbo中，我们支持4种嵌入式rest server的实现，并同时支持采用外部应用服务器来做rest server的实现。rest server的实现是通过如下server这个XML属性来选择的：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">server=</span><span class="s">"jetty"</span><span class="nt">/&gt;</span>
</pre></div><p>以上配置选用了嵌入式的jetty来做rest server，同时，如果不配置server属性，rest协议默认也是选用jetty。jetty是非常成熟的java servlet容器，并和dubbo已经有较好的集成（目前4种嵌入式server中只有jetty和后面所述的tjws server，与dubbo监控系统等完成了无缝的集成），所以，如果你的dubbo系统是单独启动的进程，建议你直接默认采用jetty即可。</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">server=</span><span class="s">"netty"</span><span class="nt">/&gt;</span>
</pre></div><p>以上配置选用嵌入式的netty来做rest server。（TODO more contents to add）</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">server=</span><span class="s">"tjws"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">server=</span><span class="s">"sunhttp"</span><span class="nt">/&gt;</span>
</pre></div><p>以上配置选用嵌入式的tjws或Sun HTTP server来做rest server。这两个server实现非常轻量级，非常方便在集成测试中快速启动使用，当然也可以在负荷不高的生产环境中使用。</p><p>如果你的dubbo系统不是单独启动的进程，而是部署到了Java应用服务器中，则建议你采用以下配置：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">server=</span><span class="s">"servlet"</span><span class="nt">/&gt;</span>
</pre></div><p>通过将server设置为servlet，dubbo将采用外部应用服务器的servlet容器来做rest server。同时，还要在dubbo系统的web.xml中添加如下配置：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;web-app&gt;</span>
    <span class="nt">&lt;context-param&gt;</span>
        <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
        <span class="nt">&lt;param-value&gt;</span>/WEB-INF/classes/META-INF/spring/dubbo-demo-provider.xml<span class="nt">&lt;/param-value&gt;</span>
    <span class="nt">&lt;/context-param&gt;</span>

    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>com.alibaba.dubbo.remoting.http.servlet.BootstrapListener<span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>

    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>

    <span class="nt">&lt;servlet&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>dispatcher<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;servlet-class&gt;</span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet<span class="nt">&lt;/servlet-class&gt;</span>
        <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
    <span class="nt">&lt;/servlet&gt;</span>

    <span class="nt">&lt;servlet-mapping&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>dispatcher<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/servlet-mapping&gt;</span>
<span class="nt">&lt;/web-app&gt;</span>
</pre></div><p>即必须将dubbo的BootstrapListener和DispatherServlet添加到web.xml，以完成dubbo的REST功能与外部servlet容器的集成。</p><blockquote><p>注意：如果你是用spring的ContextLoaderListener来加载spring，则必须保证BootstrapListener配置在ContextLoaderListener之前，否则dubbo初始化会出错。</p></blockquote><p>其实，这种场景下你依然可以坚持用嵌入式server，但外部应用服务器的servlet容器往往比嵌入式server更加强大（特别是如果你是部署到更健壮更可伸缩的WebLogic，WebSphere等），另外有时也便于在应用服务器做统一管理、监控等等。</p><h3>获取上下文（Context）信息</h3><p>在远程调用中，值得获取的上下文信息可能有很多种，这里特别以获取客户端IP为例。</p><p>在dubbo的REST中，我们有两种方式获取客户端IP。</p><p>第一种方式，用JAX-RS标准的<a href="https://github.com/Context" class="user-mention">@Context</a> annotation：</p><div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@PathParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">,</span> <span class="nd">@Context</span> <span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Client address is"</span> <span class="o">+</span> <span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">());</span>
<span class="o">}</span> 
</pre></div><p>用Context修饰getUser()的一个方法参数后，就可以将当前的HttpServletRequest注入进来，然后直接调用servlet api获取IP。</p><blockquote><p>注意：这种方式只能在设置server="tjws"或者server="jetty"或者server="servlet"的时候才能工作，因为只有这三种REST server的实现才提供了servlet容器。另外，标准的JAX-RS还支持用<a href="https://github.com/Context" class="user-mention">@Context</a>修饰service类的一个实例字段来获取HttpServletRequest，但在dubbo中我们没有对此作出支持。</p></blockquote><p>第二种方式，用dubbo中常用的RpcContext：</p><div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@PathParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Client address is "</span> <span class="o">+</span> <span class="n">RpcContext</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getRemoteAddressString</span><span class="o">());</span>
<span class="o">}</span> 
</pre></div><blockquote><p>注意：这种方式只能在设置server="jetty"或者server="servlet"或者server="tjws"的时候才能工作。另外，目前dubbo的RpcContext是一种比较有侵入性的用法，未来我们很可能会做出重构。</p></blockquote><p>如果你想保持你的项目对JAX-RS的兼容性，未来脱离dubbo也可以运行，请选择第一种方式。如果你想要更优雅的服务接口定义，请选用第二种方式。</p><h3>配置端口号和Context Path</h3><p>dubbo中的rest协议默认将采用80端口，如果想修改端口，直接配置：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">port=</span><span class="s">"8888"</span><span class="nt">/&gt;</span>
</pre></div><p>另外，如前所述，我们可以用<a href="https://github.com/Path" class="user-mention">@Path</a>来配置单个rest服务的URL相对路径。但其实，我们还可以设置一个所有rest服务都适用的基础相对路径，即java web应用中常说的context path。</p><p>只需要添加如下contextpath属性即可：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">port=</span><span class="s">"8888"</span> <span class="na">contextpath=</span><span class="s">"services"</span><span class="nt">/&gt;</span>
</pre></div><p>以前面代码为例：</p><div class="highlight highlight-java"><pre><span class="nd">@Path</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceImpl</span> <span class="kd">implements</span> <span class="n">UserService</span> <span class="o">{</span>

    <span class="nd">@POST</span>
    <span class="nd">@Path</span><span class="o">(</span><span class="s">"register"</span><span class="o">)</span>
    <span class="nd">@Consumes</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">})</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerUser</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// save the user...</span>
    <span class="o">}</span>   
<span class="o">}</span>
</pre></div><p>现在registerUser()的完整访问路径为：</p><pre><code>http://localhost:8888/services/users/register
</code></pre><p>注意：如果你是选用外部应用服务器做rest server，即配置:</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">port=</span><span class="s">"8888"</span> <span class="na">contextpath=</span><span class="s">"services"</span> <span class="na">server=</span><span class="s">"servlet"</span><span class="nt">/&gt;</span>
</pre></div><p>则必须保证这里设置的port、contextpath，与外部应用服务器的端口、DispatcherServlet的contextpath保持一致。例如，对于部署为tomcat ROOT路径的应用，这里的contextpath必须与web.xml中DispacherServlet的<code>&lt;url-pattern/&gt;</code>完全一致：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;servlet-mapping&gt;</span>
     <span class="nt">&lt;servlet-name&gt;</span>dispatcher<span class="nt">&lt;/servlet-name&gt;</span>
     <span class="nt">&lt;url-pattern&gt;</span>/services/*<span class="nt">&lt;/url-pattern&gt;</span>
<span class="nt">&lt;/servlet-mapping&gt;</span>
</pre></div><h3>配置线程数和IO线程数</h3><p>可以为rest服务配置线程池大小：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">threads=</span><span class="s">"500"</span><span class="nt">/&gt;</span>
</pre></div><blockquote><p>注意：目前线程池的设置只有当server="netty"或者server="jetty"的时候才能生效。另外，如果server="servlet"，由于这时候启用的是外部应用服务器做rest server，不受dubbo控制，所以这里的线程池设置也无效。</p></blockquote><p>如果是选用netty server，还可以配置Netty的IO worker线程数：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">iothreads=</span><span class="s">"5"</span> <span class="na">threads=</span><span class="s">"100"</span><span class="nt">/&gt;</span>
</pre></div><h3>配置长连接</h3><p>Dubbo中的rest服务默认都是采用http长连接来访问，如果想切换为短连接，直接配置：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">keepalive=</span><span class="s">"false"</span><span class="nt">/&gt;</span>
</pre></div><blockquote><p>注意：这个配置目前只对server="netty"才能生效。</p></blockquote><h3>配置消费端的超时时间和HTTP连接数</h3><p>如果rest服务的消费端也是dubbo系统，可以像其他dubbo RPC机制一样，配置消费端调用此rest服务的最大超时时间以及每个消费端所能启动的最大HTTP连接数。</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"xxx"</span> <span class="na">ref=</span><span class="s">"xxx"</span> <span class="na">protocol=</span><span class="s">"rest"</span> <span class="na">timeout=</span><span class="s">"2000"</span> <span class="na">connections=</span><span class="s">"10"</span><span class="nt">/&gt;</span>
</pre></div><p>当然，由于这个配置针对消费端生效的，所以也可以在消费端配置：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"xxx"</span> <span class="na">interface=</span><span class="s">"xxx"</span> <span class="na">timeout=</span><span class="s">"2000"</span> <span class="na">connections=</span><span class="s">"10"</span><span class="nt">/&gt;</span>
</pre></div><p>但是，通常我们建议配置在服务提供端提供此类配置。按照dubbo官方文档的说法：“Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题。”</p><blockquote><p>注意：如果dubbo的REST服务是发布给非dubbo的客户端使用，则这里<code>&lt;dubbo:service/&gt;</code>上的配置完全无效，因为这种客户端不受dubbo控制。</p></blockquote><h3>GZIP数据压缩</h3><p>Dubbo的REST支持用GZIP压缩请求和响应的数据，以减少网络传输时间和带宽占用，但这种方式会也增加CPU开销。</p><p>TODO more contents to add</p><h3>是否应该透明发布REST服务</h3><p>Dubbo的REST调用和dubbo中其它某些RPC不同的是，需要在服务代码中添加JAX-RS的annotation（以及JAXB、Jackson的annotation），如果你觉得这些annotation一定程度“污染”了你的服务代码，你可以考虑编写额外的Facade和DTO类，在Facade和DTO上添加annotation，而Facade将调用转发给真正的服务实现类。当然事实上，直接在服务代码中添加annotation基本没有任何负面作用，而且这本身是Java EE的标准用法，另外JAX-RS和JAXB的annotation是属于java标准，比我们经常使用的spring、dubbo等等annotation更没有vendor lock-in的问题，所以一般没有必要因此而引入额外对象。</p><p>另外，如果你想用前述的<a href="https://github.com/Context" class="user-mention">@Context</a> annotation，通过方法参数注入HttpServletRequest（如<code>public User getUser(@PathParam("id") Long id, @Context HttpServletRequest request)</code>），这时候由于改变了服务的方法签名，并且HttpServletRequest是REST特有的参数，如果你的服务要支持多种RPC机制的话，则引入额外的Facade类是比较适当的。</p><p>当然，在没有添加REST调用之前，你的服务代码可能本身已经就充当了Facade和DTO的角色（至于为什么有些场景需要这些角色，有兴趣可参考《微观SOA：服务设计原则及其实践方式》）。这种情况下，在添加REST之后，如果你再额外添加与REST相关的Facade和DTO，就相当于对原有代码对再一次包装，即形成如下调用链：</p><p><code>RestFacade/RestDTO -&gt; Facade/DTO -&gt; Service</code></p><p>这种体系比较繁琐，数据转换之类的工作量也不小，所以一般应尽量避免如此。</p><h3>用Annotation取代部分Spring XML配置</h3><p>以上所有的讨论都是基于dubbo在spring中的xml配置。但是，dubbo/spring本身也支持用annotation来作配置，所以我们也可以按dubbo官方文档中的步骤，把相关annotation加到REST服务的实现中，取代一些xml配置，例如：</p><div class="highlight highlight-java"><pre><span class="nd">@Service</span><span class="o">(</span><span class="n">protocol</span> <span class="o">=</span> <span class="s">"rest"</span><span class="o">)</span>
<span class="nd">@Path</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceImpl</span> <span class="kd">implements</span> <span class="n">UserService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="n">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>

    <span class="nd">@POST</span>
    <span class="nd">@Path</span><span class="o">(</span><span class="s">"register"</span><span class="o">)</span>
    <span class="nd">@Consumes</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">})</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerUser</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// save the user</span>
        <span class="n">userRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="o">}</span>   
<span class="o">}</span>
</pre></div><p>annotation的配置更简单更精确，经常也更便于维护（当然现代IDE都可以在xml中支持比如类名重构，所以就这里的特定用例而言，xml的维护性也很好）。而xml对代码对侵入性更小一些，尤其有利于动态修改配置，特别是比如你要针对单个服务配置连接超时时间、每客户端最大连接数、集群策略、权重等等。另外，特别对复杂应用或者模块来说，xml提供了一个中心点来涵盖的所有组件和配置，更一目了然，一般更便于项目长时期的维护。</p><p>当然，选择哪种配置方式没有绝对的优劣，和个人的偏好也不无关系。</p><h3>添加自定义的Filter、Interceptor等</h3><blockquote><p>注：高级特性，一般人可忽略此节</p></blockquote><p>Dubbo的REST也支持JAX-RS标准的Filter和Interceptor，以方便对REST的请求与响应过程做定制化的拦截处理。</p><p>其中，Filter主要用于访问和设置HTTP请求和响应的参数、URI等等。例如，设置HTTP响应的cache header：</p><div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CacheControlFilter</span> <span class="kd">implements</span> <span class="n">ContainerResponseFilter</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ContainerRequestContext</span> <span class="n">req</span><span class="o">,</span> <span class="n">ContainerResponseContext</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"GET"</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">getHeaders</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"Cache-Control"</span><span class="o">,</span> <span class="s">"someValue"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div><p>Interceptor主要用于访问和修改输入与输出字节流，例如，手动添加GZIP压缩：</p><div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GZIPWriterInterceptor</span> <span class="kd">implements</span> <span class="n">WriterInterceptor</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">aroundWriteTo</span><span class="o">(</span><span class="n">WriterInterceptorContext</span> <span class="n">context</span><span class="o">)</span>
                    <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">WebApplicationException</span> <span class="o">{</span>
        <span class="n">OutputStream</span> <span class="n">outputStream</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>
        <span class="n">context</span><span class="o">.</span><span class="na">setOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nf">GZIPOutputStream</span><span class="o">(</span><span class="n">outputStream</span><span class="o">));</span>
        <span class="n">context</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div><p>在标准JAX-RS应用中，我们一般是为Filter和Interceptor添加<a href="https://github.com/Provider" class="user-mention">@Provider</a> annotation，然后JAX-RS runtime会自动发现并启用它们。而在dubbo中，我们是通过添加XML配置的方式来注册Filter和Interceptor：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"rest"</span> <span class="na">port=</span><span class="s">"8888"</span> <span class="na">extension=</span><span class="s">"xxx.TraceInterceptor, xxx.TraceFilter"</span><span class="nt">/&gt;</span>
</pre></div><p>在此，我们可以将Filter、Interceptor和DynamicFuture这三种类型的对象都添加到extension属性上，多个之间用逗号分隔。（DynamicFuture是另一个接口，可以方便我们更动态的启用Filter和Interceptor，感兴趣请自行google。）</p><p>当然，dubbo自身也支持Filter的概念，但我们这里讨论的Filter和Interceptor更加接近协议实现的底层，相比dubbo的filter，可以做更底层的定制化。</p><blockquote><p>注：这里的XML属性叫extension，而不是叫interceptor或者filter，是因为除了Interceptor和Filter，未来我们还会添加更多的扩展类型。</p></blockquote><p>如果REST的消费端也是dubbo系统（参见下文的讨论），则也可以用类似方式为消费端配置Interceptor和Filter。但注意，JAX-RS中消费端的Filter和提供端的Filter是两种不同的接口。例如前面例子中服务端是ContainerResponseFilter接口，而消费端对应的是ClientResponseFilter:</p><div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoggingFilter</span> <span class="kd">implements</span> <span class="n">ClientResponseFilter</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">filter</span><span class="o">(</span><span class="n">ClientRequestContext</span> <span class="n">reqCtx</span><span class="o">,</span> <span class="n">ClientResponseContext</span> <span class="n">resCtx</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"status: "</span> <span class="o">+</span> <span class="n">resCtx</span><span class="o">.</span><span class="na">getStatus</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"date: "</span> <span class="o">+</span> <span class="n">resCtx</span><span class="o">.</span><span class="na">getDate</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"last-modified: "</span> <span class="o">+</span> <span class="n">resCtx</span><span class="o">.</span><span class="na">getLastModified</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"location: "</span> <span class="o">+</span> <span class="n">resCtx</span><span class="o">.</span><span class="na">getLocation</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"headers:"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">header</span> <span class="o">:</span> <span class="n">resCtx</span><span class="o">.</span><span class="na">getHeaders</span><span class="o">().</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"\t"</span> <span class="o">+</span> <span class="n">header</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">" :"</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">value</span> <span class="o">:</span> <span class="n">header</span><span class="o">.</span><span class="na">getValue</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="s">", "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"media-type: "</span> <span class="o">+</span> <span class="n">resCtx</span><span class="o">.</span><span class="na">getMediaType</span><span class="o">().</span><span class="na">getType</span><span class="o">());</span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></div><h2>REST服务消费端详解</h2><p>这里我们用三种场景来分别讨论：</p><ol class="task-list"><li>非dubbo的消费端调用dubbo的REST服务（non-dubbo --&gt; dubbo）</li><li>dubbo消费端调用dubbo的REST服务 （dubbo --&gt; dubbo）</li><li>dubbo的消费端调用非dubbo的REST服务 （dubbo --&gt; non-dubbo）</li></ol><h3>场景1：非dubbo的消费端调用dubbo的REST服务</h3><p>这种场景的客户端与dubbo本身无关，直接选用相应语言和框架中合适的方式即可。</p><p>如果是还是java的客户端（但没用dubbo），可以考虑直接使用标准的JAX-RS Client API或者特定REST实现的Client API来调用REST服务。下面是用JAX-RS Client API来访问上述的UserService的registerUser()：</p><div class="highlight highlight-java"><pre><span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">User</span><span class="o">();</span>
<span class="n">user</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"Larry"</span><span class="o">);</span>

<span class="n">Client</span> <span class="n">client</span> <span class="o">=</span> <span class="n">ClientBuilder</span><span class="o">.</span><span class="na">newClient</span><span class="o">();</span>
<span class="n">WebTarget</span> <span class="n">target</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">target</span><span class="o">(</span><span class="s">"http://localhost:8080/services/users/register.json"</span><span class="o">);</span>
<span class="n">Response</span> <span class="n">response</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">request</span><span class="o">().</span><span class="na">post</span><span class="o">(</span><span class="n">Entity</span><span class="o">.</span><span class="na">entity</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON_TYPE</span><span class="o">));</span>

<span class="k">try</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getStatus</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">200</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Failed with HTTP error code : "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">getStatus</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The generated id is "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">readEntity</span><span class="o">(</span><span class="n">RegistrationResult</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getId</span><span class="o">());</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">response</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="n">client</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 在真正开发中不要每次关闭client，比如HTTP长连接是由client持有的</span>
<span class="o">}</span>
</pre></div><p>上面代码片段中的User和RegistrationResult类都是消费端自己编写的，JAX-RS Client API会自动对它们做序列化/反序列化。</p><p>当然，在java中也可以直接用自己熟悉的比如HttpClient，FastJson，XStream等等各种不同技术来实现REST客户端，在此不再详述。</p><h3>场景2：dubbo消费端调用dubbo的REST服务</h3><p>这种场景下，和使用其他dubbo的远程调用方式一样，直接在服务提供端和服务消费端共享Java服务接口，并添加spring xml配置（当然也可以用spring/dubbo的annotation配置），即可透明的调用远程REST服务：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"userService"</span> <span class="na">interface=</span><span class="s">"xxx.UserService"</span><span class="nt">/&gt;</span>
</pre></div><p>如前所述，这种场景下必须把JAX-RS的annotation添加到服务接口上，这样在dubbo在消费端才能共享相应的REST配置信息，并据之做远程调用:</p><div class="highlight highlight-java"><pre><span class="nd">@Path</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserService</span> <span class="o">{</span>

    <span class="nd">@GET</span>
    <span class="nd">@Path</span><span class="o">(</span><span class="s">"{id : \\d+}"</span><span class="o">)</span>
    <span class="nd">@Produces</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">,</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">})</span>
    <span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@PathParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</pre></div><p>如果服务接口的annotation中配置了多种数据格式，这里由于两端都是dubbo系统，REST的大量细节被屏蔽了，所以不存在用前述URL后缀之类选择数据格式的可能。目前在这种情况下，排名最靠前的数据格式将直接被使用。</p><p>因此，我们建议你在定义annotation的时候最好把最合适的数据格式放到前面，比如以上我们是把json放在xml前面，因为json的传输性能优于xml。</p><h3>场景3：dubbo的消费端调用非dubbo的REST服务</h3><p>这种场景下，可以直接用场景1中描述的Java的方式来调用REST服务。但其实也可以采用场景2中描述的方式，即更透明的调用REST服务，即使这个服务并不是dubbo提供的。</p><p>如果用场景2的方式，由于这里REST服务并非dubbo提供，一般也就没有前述的共享的Java服务接口，所以在此我们需要根据外部REST服务的情况，自己来编写Java接口以及相应参数类，并添加JAX-RS、JAXB、Jackson等的annotation，dubbo的REST底层实现会据此去自动生成请求消息，自动解析响应消息等等，从而透明的做远程调用。或者这种方式也可以理解为，我们尝试用JAX-RS的方式去仿造实现一遍外部的REST服务提供端，然后把写成服务接口放到客户端来直接使用，dubbo的REST底层实现就能像调用dubbo的REST服务一样调用其他REST服务。</p><p>例如，我们要调用如下的外部服务</p><pre><code>http://api.foo.com/services/users/1001
http://api.foo.com/services/users/1002
</code></pre><p>获取不同ID的用户资料，返回格式是JSON</p><div class="highlight highlight-javascript"><pre><span class="p">{</span>
    <span class="s2">"id"</span><span class="o">:</span> <span class="mi">1001</span><span class="p">,</span>
    <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"Larry"</span>
<span class="p">}</span>
</pre></div><p>我们可根据这些信息，编写服务接口和参数类即可：</p><div class="highlight highlight-java"><pre><span class="nd">@Path</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserService</span> <span class="o">{</span>

    <span class="nd">@GET</span>
    <span class="nd">@Path</span><span class="o">(</span><span class="s">"{id : \\d+}"</span><span class="o">)</span>
    <span class="nd">@Produces</span><span class="o">({</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">})</span>
    <span class="n">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="nd">@PathParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="n">Long</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</pre></div><div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="c1">// …</span>
<span class="o">}</span>
</pre></div><p>对于spring中的配置，因为这里的REST服务不是dubbo提供的，所以无法使用dubbo的注册中心，直接配置外部REST服务的url地址即可（如多个地址用逗号分隔）：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"userService"</span> <span class="na">interface=</span><span class="s">"xxx.UserService"</span> <span class="na">url=</span><span class="s">"rest://api.foo.com/services/"</span><span class="nt">/&gt;</span>
</pre></div><blockquote><p>注意：这里协议必须用rest://而不是http://之类。如果外部的REST服务有context path，则在url中也必须添加上（除非你在每个服务接口的<a href="https://github.com/Path" class="user-mention">@Path</a> annotation中都带上context path），例如上面的/services/。同时这里的services后面必须带上/，这样才能使dubbo正常工作。</p></blockquote><p>另外，这里依然可以配置客户端可启动的最大连接数和超时时间：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"userService"</span> <span class="na">interface=</span><span class="s">"xxx.UserService"</span> <span class="na">url=</span><span class="s">"rest://api.foo.com/services/"</span> <span class="na">timeout=</span><span class="s">"2000"</span> <span class="na">connections=</span><span class="s">"10"</span><span class="nt">/&gt;</span>
</pre></div><h2>Dubbo中JAX-RS的限制</h2><p>Dubbo中的REST开发是完全兼容标准JAX-RS的，但其支持的功能目前是完整JAX-RS的一个子集，部分因为它要受限于dubbo和spring的特定体系。</p><p>在dubbo中使用的JAX-RS的局限包括但不限于：</p><ol class="task-list"><li>服务实现只能是singleton的，不能支持per-request scope和per-lookup scope</li><li>不支持用<a href="https://github.com/Context" class="user-mention">@Context</a> annotation对服务的实例字段注入 ServletConfig、ServletContext、HttpServletRequest、HttpServletResponse等等，但可以支持对服务方法参数的注入。但对某些特定REST server实现，（祥见前面的叙述），也不支持对服务方法参数的注入。</li></ol><h2>Dubbo当前体系的不足之处（与REST相关的）</h2><p>我认为dubbo当前体系中显然也有不少不足之处，这里列出几个与REST有关的、并影响用户使用的问题（不包括内部实现的问题），供参考评论，为下一步重构作准备。</p><h3>RpcContext的侵入性</h3><p>在前文，前面我们已经提到过RpcContext用法的侵入性，由于它是用单例的方式来访问上下文信息，这完全不符合spring应用的一般风格，不利于应用扩展和单元测试。未来我们可能用依赖注入方式注入一个接口，再用它去访问ThreadLocal中的上下文信息。</p><h3>Protocol配置的局限性</h3><p>dubbo支持多种远程调用方式，但所有调用方式都是用<code>&lt;dubbo:protocol/&gt;</code>来配置的，例如：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">port=</span><span class="s">"9090"</span> <span class="na">server=</span><span class="s">"netty"</span> <span class="na">client=</span><span class="s">"netty"</span> <span class="na">codec=</span><span class="s">"dubbo"</span> <span class="na">serialization=</span><span class="s">"hessian2"</span> 
    <span class="na">charset=</span><span class="s">"UTF-8"</span> <span class="na">threadpool=</span><span class="s">"fixed"</span> <span class="na">threads=</span><span class="s">"100"</span> <span class="na">queues=</span><span class="s">"0"</span> <span class="na">iothreads=</span><span class="s">"9"</span> <span class="na">buffer=</span><span class="s">"8192"</span> <span class="na">accepts=</span><span class="s">"1000"</span> <span class="na">payload=</span><span class="s">"8388608"</span><span class="nt">/&gt;</span>
</pre></div><p>其实，上面很多属性实际上dubbo RPC远程调用方式特有的，很多dubbo中的其它远程调用方式根本就不支持例如server, client, codec, iothreads, accepts, payload等等（当然，有的是条件所限不支持，有的是根本没有必要支持）。这给用户的使用徒增很多困惑，用户也并不知道有些属性（比如做性能调优）添加了实际上是不起作用的。</p><p>另一方面，各种远程调用方式往往有大量自己独特的配置需要，特别是我们逐步为每种远程调用方式都添加更丰富、更高级的功能，这就不可避免的扩展<code>&lt;protocol/&gt;</code>中的属性（例如目前我们在REST中已经添加了keepalive和extension两个属性），到最后会导致<code>&lt;protocol/&gt;</code>臃肿不堪，用户的使用也更加困惑。</p><p>当然，dubbo中有一种扩展<code>&lt;protocol/&gt;</code>的方式是用<code>&lt;dubbo:parameter/&gt;</code>，但这种方式显然很有局限性，而且用法复杂，缺乏schema校验。</p><p>所以，最好的方式是为每种远程调用方式设置自己的protocol元素，比如<code>&lt;protocol-dubbo/&gt;</code>，<code>&lt;protocol-rest/&gt;</code>等等，每种元素用XML schema规定自己的属性（当然属性在各种远程调用方式之间能通用是最好的）。</p><p>如此一来，例如前面提到过的extension配置也可以用更自由的方式，从而更清楚更可扩展（以下只是举例，当然也许有更好的方式）:</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol-rest</span> <span class="na">port=</span><span class="s">"8080"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dubbo:extension&gt;</span>someInterceptor<span class="nt">&lt;/dubbo:extension&gt;</span>
    <span class="nt">&lt;dubbo:extension&gt;</span>someFilter<span class="nt">&lt;/dubbo:extension&gt;</span>
    <span class="nt">&lt;dubbo:extension&gt;</span>someDynamicFeature<span class="nt">&lt;/dubbo:extension&gt;</span>
    <span class="nt">&lt;dubbo:extension&gt;</span>someEntityProvider<span class="nt">&lt;/dubbo:extension&gt;</span>
<span class="nt">&lt;/dubbo:protocol-rest&gt;</span>
</pre></div><h3>XML命名不符合spring规范</h3><p>dubbo的XML配置中大量命名都不符合spring规范，比如：</p><div class="highlight highlight-xml"><pre><span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">port=</span><span class="s">"9090"</span> <span class="na">server=</span><span class="s">"netty"</span> <span class="na">client=</span><span class="s">"netty"</span> <span class="na">codec=</span><span class="s">"dubbo"</span> <span class="na">serialization=</span><span class="s">"hessian2"</span> 
    <span class="na">charset=</span><span class="s">"UTF-8"</span> <span class="na">threadpool=</span><span class="s">"fixed"</span> <span class="na">threads=</span><span class="s">"100"</span> <span class="na">queues=</span><span class="s">"0"</span> <span class="na">iothreads=</span><span class="s">"9"</span> <span class="na">buffer=</span><span class="s">"8192"</span> <span class="na">accepts=</span><span class="s">"1000"</span> <span class="na">payload=</span><span class="s">"8388608"</span><span class="nt">/&gt;</span>
</pre></div><p>上面threadpool应该改为thread-pool，iothreads应该改为io-threads，单词之间应该用"-"分隔。这虽然看起来是个小问题，但也涉及到了可读性，特别是可扩展性，因为有时候我们不可避免要用更多单词来描述XML元素和属性。</p><p>其实dubbo本身也是建议遵守spring到XML的命名规范。</p><h2>REST最佳实践</h2><p>TODO</p><h2>性能基准测试</h2><h3>测试环境</h3><p>粗略如下：</p><ul class="task-list"><li>两台独立服务器</li><li>4核Intel(R) Xeon(R) CPU E5-2603 0 @ 1.80GHz</li><li>8G内存</li><li>虚拟机之间网络通过百兆交换机</li><li>CentOS 5</li><li>JDK 7</li><li>Tomcat 7</li><li>JVM参数-server -Xms1g -Xmx1g -XX:PermSize=64M -XX:+UseConcMarkSweepGC</li></ul><h3>测试脚本</h3><p>和dubbo自身的基准测试保持接近：</p><p>10个并发客户端持续不断发出请求：</p><ul class="task-list"><li>传入嵌套复杂对象（但单个数据量很小），不做任何处理，原样返回</li><li>传入50K字符串，不做任何处理，原样返回（TODO：结果尚未列出）</li></ul><p>进行5分钟性能测试。（引用dubbo自身测试的考虑：“主要考察序列化和网络IO的性能，因此服务端无任何业务逻辑。取10并发是考虑到http协议在高并发下对CPU的使用率较高可能会先打到瓶颈。”）</p><h3>测试结果</h3><p>下面的结果主要对比的是REST和dubbo RPC两种远程调用方式，并对它们作不同的配置，例如：</p><ul class="task-list"><li>“REST: Jetty + XML + GZIP”的意思是：测试REST，并采用jetty server，XML数据格式，启用GZIP压缩。</li><li>“Dubbo: hessian2”的意思是：测试dubbo RPC，并采用hessian2序列化方式。</li></ul><p>针对复杂对象的结果如下（响应时间越小越好，TPS越大越好）：</p><table><thead><tr><th>远程调用方式</th><th>平均响应时间</th><th>平均TPS（每秒事务数）</th></tr></thead><tbody><tr><td>REST: Jetty + JSON</td><td>7.806</td><td>1280</td></tr><tr><td>REST: Jetty + JSON + GZIP</td><td>TODO</td><td>TODO</td></tr><tr><td>REST: Jetty + XML</td><td>TODO</td><td>TODO</td></tr><tr><td>REST: Jetty + XML + GZIP</td><td>TODO</td><td>TODO</td></tr><tr><td>REST: Tomcat + JSON</td><td>2.082</td><td>4796</td></tr><tr><td>REST: Netty + JSON</td><td>2.182</td><td>4576</td></tr><tr><td>Dubbo: FST</td><td>1.211</td><td>8244</td></tr><tr><td>Dubbo: kyro</td><td>1.182</td><td>8444</td></tr><tr><td>Dubbo: dubbo serialization</td><td>1.43</td><td>6982</td></tr><tr><td>Dubbo: hessian2</td><td>1.49</td><td>6701</td></tr><tr><td>Dubbo: fastjson</td><td>1.572</td><td>6352</td></tr></tbody></table><p><a href="images/rt.png" target="_blank"><img src="images/rt.png" alt="no image found" style="max-width:100%"></a></p><p><a href="images/tps.png" target="_blank"><img src="images/tps.png" alt="no image found" style="max-width:100%"></a></p><p>仅就目前的结果，一点简单总结：</p><ul class="task-list"><li>dubbo RPC（特别是基于高效java序列化方式如kryo，fst）比REST的响应时间和吞吐量都有较显著优势，内网的dubbo系统之间优先选择dubbo RPC。</li><li>在REST的实现选择上，仅就性能而言，目前tomcat7和netty最优（当然目前使用的jetty和netty版本都较低）。tjws和sun http server在性能测试中表现极差，平均响应时间超过200ms，平均tps只有50左右（为了避免影响图片效果，没在上面列出）。</li><li>在REST中JSON数据格式性能优于XML（数据暂未在以上列出）。</li><li>在REST中启用GZIP对企业内网中的小数据量复杂对象帮助不大，性能反而有下降（数据暂未在以上列出）。</li></ul><h2>性能优化建议</h2><p>TODO</p><h2>扩展讨论</h2><h3>REST与Thrift、Protobuf等的对比</h3><p>TODO</p><h3>REST与传统WebServices的对比</h3><p>TODO</p><h3>JAX-RS与Spring MVC的对比</h3><p>TODO</p><h2>未来</h2><p>稍后可能要实现的功能：</p><ul class="task-list"><li>消息调试</li><li>spring mvc的rest annotation支持</li><li>服务器端接纳的最大连接数</li><li>安全</li><li>OAuth</li><li>异步调用</li><li>完善gzip</li></ul></body></html>